# CVE-2022-21661 WordPress 5.8.3 SQL注入漏洞

本文仅用于技术讨论与研究，文中的实现方法切勿应用在任何违法场景。如因涉嫌违法造成的一切不良影响，本文作者概不负责。

> 本文由本人在今年2月份发表于奇安信攻防社区 https://forum.butian.net/share/1324 ，因此在一些关于时间的描述上存在误差，请谅解。

## 0x00 漏洞描述

这是最近爆出来的一个 `wordpress`的`SQL`注入漏洞，实际上不是一个可以直接利用的洞，而是`wordpress`的一个核心函数 `WP_Query`的漏洞，这个函数常被插件使用，因此能造成的危害也挺大，前台后台都有可能。

## 0x01 漏洞影响

`wordpress < 5.8.3`
这里是修复链接
[https://github.com/WordPress/WordPress/commit/6f7032dcf423b67f90381d4f29a90d16f4829070](https://github.com/WordPress/WordPress/commit/6f7032dcf423b67f90381d4f29a90d16f4829070)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645102019548-1c3129e9-7c36-4ce2-9de3-8cd16cb0ae77.png)
我们 `git`下载后，恢复到上一个版本

```php
git clone https://github.com/WordPress/WordPress
git checkout 266c58518846
```

## 0x02 漏洞分析

因为此漏洞在插件中出现较多，因此这里我们也造一个插件来进行测试复现，网上已经有师傅写好了 `demo`，我这里直接用

```php
<?php
/*
Plugin Name: CVE-2022-21661-test-plugin
Plugin URL: https://www.lsablog.com/networksec/penetration/cve-2022-21661-wordpress-core-sqli-analysis
Description: This plugin was made in order to test CVE-2022-21661 (wordpress core sql injection)
Version: v1.0
Author: LSA
Author's Blog: https://www.lsablog.com/
License: MIT
*/

function testSQLiCVE202221661(){


echo 'test-cve-2022-21661-plugin';

    $inputData = stripslashes($_POST['data']);
    $jsonDecodeInputData = json_decode($inputData,true);
    $wpTest = new WP_Query($jsonDecodeInputData);
    wp_die();
}

add_action('wp_ajax_nopriv_testcve202221661','testSQLiCVE202221661');
```

写入 `php`文件，打包成 `zip`格式，后台安装插件并启用
这里的插件是不用权限就可以访问的，`admin`权限访问反而存在问题，正常访问显示如下
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645103521554-d2846aaf-7df3-46e6-a553-003e4d061141.png)
好了，接下来开始调试，看到插件代码，位于 `wp-content/plugins/CVE-2022-21661-test-plugin/CVE-2022-21661-test-plugin.php`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645103635627-6bddf23b-653a-4b46-b4c8-3f3cb0f75a9b.png)
`post`的`data`使用了 `stripslashes`，`post`的参数默认会被转义，因此用这个函数去掉转义符等，然后 `json_decode`解码，也就是说我们传入的数据需要是 `json`格式的，最后传入 `WP_Query`
跟进 `wp-includes/class-wp-query.php`的构造方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645104192903-4b660d49-8c12-4c3a-8962-dde93ee542c6.png)
继续跟进 `query`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645104421273-bc080a34-fa1a-4c53-8e20-aeeff30a5855.png)
`$query`是我们传入的 `json`解码后的数据，处理一下后进入 `get_posts`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645104830365-2be61a3c-870b-4018-a423-0f88356f5293.png)
将 `$this->query_vars`赋值给了 `$q`，然后还加入了一些其他的参数，因此 `$q`部分可控，继续往下看
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645105048461-3fc7776d-941d-4d52-95f0-9975d9fe1fa5.png)
`$this->is_singular`默认为 `false`，进入 `if`语句，然后使用 `parse_tax_query`方法处理 `$q`，我们看看代码
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645340595117-4f864e36-96ca-4bf9-968e-33c3e2e2d0fe.png)
在这里，`$q`中存在的一些值会赋值给 `$tax_query`，比如，`$q`中存在 `tax_query`这个键并且是数组的时候，就会将他的值存入 `$tax_query`，拉到最后可以看到实例化了 `WP_Tax_Query`，而 `$tax_query`的值就会作为初始化的值传入 `WP_Tax_Query`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645340962424-faaba21b-6d7a-4359-a1cb-62f87e39c70a.png)
看到 `wp-includes/class-wp-tax-query.php`中的 `__construct`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645341126441-5696c72f-5575-4977-b827-17a1da1dcfc7.png)
跟进 `sanitize_query`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645356871711-d4b92b4a-59b2-4932-b26c-553a4ab1afa9.png)
这里是对 `$queries`的一些处理，返回值为 `$cleaned_query`，因此要找到可控的赋值
`foreach`遍历 `$queries`，使用`is_first_order_clause`进行判断
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645369819185-0728e203-6978-416a-87f5-74f6db6d42b7.png)
`$query`中存在一个值为数组，且数组的键为 `terms`就进入该分支，`$queries` 部分可控，因此很容易满足这个条件，最后和 `defaults`合并后存入 `$cleaned_query`
这里返回后的数据最后会赋值给 `$this->queries`，后面会用到这个数据
回到比较上面的`$this->tax_query->get_sql`，进入 `wp-includes/class-wp-tax-query.php`的 `get_sql`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645107644418-acac8222-7735-4e62-b20c-3d04a08d67a6.png)
继续跟进 `get_sql_clauses`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645107786798-70da1fb4-92a8-49eb-90be-5a0af23a5d7a.png)
这里就将 `$this->queries`取出来了，然后进入 `get_sql_for_query`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645109146065-168ca4d9-2bd8-46cd-ab6e-8e128dcfef3f.png)
遍历 `$query`，当 `$clause`为数组时，进入 `elseif`分支，再跟进 `is_first_order_clause`方法进行判断
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645109296540-adb8ff54-9bfb-43eb-8314-2db1e6abff59.png)
这个判断很简单，为数组且包含 `terms`这个键时为真，继续跟进上面的 `get_sql_for_clause`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645109675055-b98c4529-6679-4a87-b062-e5fc4b9253f6.png)
主要看到这个 `clean_query`方法，也是漏洞点所在的位置，这实际上是一个用于过滤潜在的危险的函数
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645109756537-8e1e4e30-45d8-4869-b87f-e8cb01102056.png)
前面的都是一些简单的判断，很容易就可以绕过，`$query['terms']`去重，最后进入 `transform_query`方法
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645110303953-72fa8b9d-66fe-4521-93d7-5c719cbcf207.png)
满足条件 `$query['field'] == $resulting_field`即可绕过这个方法，不进行其他操作
回到 `get_sql_for_clause`方法，执行完 `clean_query`后的代码如下
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645110644316-5c34cca6-eb90-448b-99ed-b2b380cc3b8c.png)
`$terms`接收 `clean_query`方法处理过的 `$clause['terms']`，当 `$operator`为 `NOT IN`时，就会拼接 `SQL`语句，造成注入，进入其他分支也是可以的，都一样，后面就不用讲了。

## 0x03 漏洞复现

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22586461/1645371797533-b52f553e-d0e1-4afb-af14-b7fe762dd1f3.png)
注意右下角的延时

## 0x04 总结

`wordpress`的漏洞还是比较少的，尤其是这种核心漏洞，使用到这个函数的插件很容易受到影响，又很难受到影响，很容易是因为使用的插件还是很多的，很难是因为输入的参数存在转义，所以需要很多的凑巧才能成功利用，不过存在一个比较大的基数，找到受影响的应该不难，连续分析了两个 `wordpress`近期的漏洞，给我的感觉就是，大的系统不是没有漏洞，而是缺少挖到他的人。

## 0x05 链接

目前在学代码审计，对此感兴趣的师傅可以加好友一起交流学习

环境与 `exp` 都可以在如下链接获取

### GitHub

https://github.com/N0puple/vulPOC

